function T_smooth = smoothTransformations(T_noisy, varargin)
% SMOOTHTRANSFORMATIONS Smooths a sequence of 4x4 rigid body transformations.
% P.s. This function is generated by Gemini 2.5. Pro (09/17/2025)
%
%   T_smooth = SMOOTHTRANSFORMATIONS(T_noisy) smooths the sequence of
%   transformations using a moving average with a window size of 5.
%
%   T_smooth = SMOOTHTRANSFORMATIONS(T_noisy, 'method', 'sgolay', 'window', 7)
%   allows specifying the smoothing method and window size passed to the
%   'smoothdata' function.
%
%   This function works on the SE(3) manifold by:
%   1. Converting the sequence of absolute poses to relative motions.
%   2. Mapping these motions to their Lie algebra representation (twist vectors).
%   3. Smoothing these vectors in the linear Lie algebra space.
%   4. Mapping the smoothed vectors back to the manifold.
%   5. Reconstructing the smoothed absolute trajectory.
%
%   Input:
%     T_noisy: A 4x4xM matrix of noisy transformation matrices.
%
%   Output:
%     T_smooth: A 4x4xM matrix of smoothed transformation matrices.

    % --- Parse optional arguments for smoothdata ---
    p = inputParser;
    addParameter(p, 'method', 'movmean', @ischar);
    addParameter(p, 'window', 5, @isnumeric);
    parse(p, varargin{:});
    
    method = p.Results.method;
    windowSize = p.Results.window;

    num_transforms = size(T_noisy, 3);
    if num_transforms < 2
        T_smooth = T_noisy;
        return;
    end

    % --- 1. Compute Relative Transformations ---
    % ΔT_i = T_i⁻¹ * T_{i+1}
    T_relative = zeros(4, 4, num_transforms - 1);
    for i = 1:(num_transforms - 1)
        T_relative(:, :, i) = T_noisy(:, :, i) \ T_noisy(:, :, i+1); % inv(A)*B is A\B
    end

    % --- 2. Map to Lie Algebra (Twist Vectors) ---
    twists_noisy = zeros(6, num_transforms - 1);
    for i = 1:(num_transforms - 1)
        se3_matrix = logm(T_relative(:, :, i));
        twists_noisy(:, i) = se3_to_twist(se3_matrix);
    end

    % --- 3. Smooth the Twist Vectors ---
    % smoothdata works on columns, so we transpose, smooth, and transpose back.
    twists_smooth = smoothdata(twists_noisy', 1, method, windowSize)';
    
    % --- 4. Map Back to Lie Group ---
    T_relative_smooth = zeros(4, 4, num_transforms - 1);
    for i = 1:(num_transforms - 1)
        se3_matrix_smooth = twist_to_se3(twists_smooth(:, i));
        T_relative_smooth(:, :, i) = expm(se3_matrix_smooth);
    end

    % --- 5. Reconstruct Smoothed Path ---
    T_smooth = zeros(size(T_noisy));
    T_smooth(:, :, 1) = T_noisy(:, :, 1); % Start with the original first pose
    for i = 1:(num_transforms - 1)
        T_smooth(:, :, i+1) = T_smooth(:, :, i) * T_relative_smooth(:, :, i);
    end
end

% % --- Helper Functions ---
% 
% function se3_mat = twist_to_se3(twist_vec)
%     % Converts a 6x1 twist vector [v; w] to a 4x4 se(3) matrix
%     v = twist_vec(1:3);
%     w = twist_vec(4:6);
%     W_hat = [  0,  -w(3),  w(2);
%              w(3),    0,  -w(1);
%             -w(2),  w(1),    0  ];
%     se3_mat = [W_hat, v; 0 0 0 0];
% end
% 
% function twist_vec = se3_to_twist(se3_mat)
%     % Converts a 4x4 se(3) matrix to a 6x1 twist vector [v; w]
%     v = se3_mat(1:3, 4);
%     W_hat = se3_mat(1:3, 1:3);
%     w = [W_hat(3,2); W_hat(1,3); W_hat(2,1)];
%     twist_vec = [v; w];
% end